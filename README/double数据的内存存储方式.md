## double 是什么
从存储结构和算法上来讲，double 和 float是一样的，不一样的地方仅仅是 float 是 3 2位的，double 是 64 位的，所以 double 能存储更高的精度。 

任何数据在内存中都是以二进制（0或1）顺序存储的，每一个1或0被称为1位，而在x86CPU上一个字节是8位。比如一个16位（2字节）的 short int型 变量的值是1000，那么它的二进制表达就是：00000011 11101000。

由于Intel CPU的架构原因，它是按字节倒序存储的，那么就因该是这样：11101000 00000011，这就是定点数1000在内存中的结构。 

目前C/C++编译器标准都遵照IEEE制定的浮点数表示法来进行float、double运算。

这种结构是一种科学计数法，用符号、指数(使用阶码的 移码 来表示) 和 尾数 来表示，底数定为2——即把一个浮点数表示为 尾数 乘以 2的指数次方 再添上符号，

其中 尾数 隐含了 "该尾数的 整数为 1，和小数点"，也正因此原因，所以 尾数的范围是 [1, 2) 的一个小数

**N = [符号] 尾数 * 2<sup>指数</sup>**

具体的规格： 
类型 |符号位数 |阶码位数 |尾数位数 |长度(位)
:--    |:--     |:--    |:--    |:--
float  |1       |8      |23     |32 
double |1       |11     |52     |64 
临时数  |1       |15     |64     |80

用阶码来表示 指数。阶码 的 最高位（左 第一位 是 阶码 的符号位，1 表示 整数，0 表示负数）


## C 编译器上的 double 数表示法
由于通常C编译器默认浮点数是 double 型的，下面以double为例： 

共计64位，即8个字节。由最高到最低位分别是 第63、62、61、...、0位： 
* 最高位第63位是符号位，1 表示该数为负，0 表示正； 
* 62-52 位，一共11位，是指数位； 
* 51-0 位，一共52位，是尾数位。
  
**示例：按照IEEE浮点数表示法，下面将把double型浮点数38414.4转换为十六进制代码**

把整数部 和 小数部分开处理：

整数部直接化十六进制：960E。

小数的处理: 

    0.4 = 0.5 * 0 + 0.25 * 1 + 0.125 * 1 + 0.0625 * 0 + ... 

小数的处理参考：http://blog.csdn.net/lin200753/article/details/27952897

## 为什么有些十进制小数无法用二进制精确表示 
有些十进制小数 是无法完全用二进制表示的。

它们只能用有限位来表示，从而在存储时可能就会有误差。

十进制的小数 采用 乘2取整法进行计算，取掉整数部分后，剩下的小数继续乘以2,直到小数部分全为0。

* 示例 0.125 转换成 二进制
```
0.125 * 2 = 0.25  // 取整 0
0.25 * 2 = 0.5  // 取整 0
0.5 * 2 = 1.0  // 取整 1
0.0 * 2 = 0  // 此时小数部为 0
```
所以 0.125 的二进制为 0.001

0.125<sub>(10)</sub> = 0.001<sub>(2)</sub>


* 示例：十进制 0.9 转成二进制小数
```
0.9 * 2 = 1.8  // 取整 1
0.8 * 2 = 1.6  // 取整 1
0.6 * 2 = 1.2  // 取整 1
0.2 * 2 = 0.4  // 取整 0
0.4 * 2 = 0.8  // 取整 0
0.8 * 2 = 1.6  // 取整1
...
```
从而它是一个循环，不可能出现小数部分为0的情况。从而在内存中表示时就会 小于 0.9

实际上这永远算不完！这就是著名的浮点数精度问题。所以直到加上前面的整数部分算够53位就行了（隐藏位技术：最高位的1不写入内存）。 

如果你够耐心，手工算到 53 位，例如：38414.4<sub>(10)</sub> = 10010110 00001110.01101 01010101 01010101 01010101 01010101<sub>(2)</sub> 

* 示例：有一个 double 小数，科学计数法表示为：1.001 * 2<sup>15</sup>

于是来看 阶码，一共 11 位，可以表示范围是 [-1024, 1023]。

因为 指数 可以为负，为了便于计算，规定都先加上 1023，所以：

15 + 1023 = 1038，

二进制表示为：100 00001110

符号位：正，用 0 表示

合在一起（尾数的表示：去掉小数点前面的1）： 

01000000 11100010 11000001 11001101 01010101 01010101 01010101 01010101

这里为了方便区分 符号位、阶码、尾数，以`,` 作为分隔符，表示如下：

0,1000000 1110,0010 11000001 11001101 01010101 01010101 01010101 01010101

按 字节 倒序 存储的 十六进制数 就是： 

55 55 55 55 CD C1 E2 40 

参考：http://blog.csdn.net/lai123wei/article/details/7220684

## C语言 和 C#语言 double、float
C语言 和 C#语言中，对于浮点类型的数据采用单精度类型（float）和双精度类型(double)来存储，float数据占用32bit, double数据占用64bit, 无论是单精度还是双精度在存储中都分为三个部分：

### 原码、反码、补码、移码。
* 符号位(Sign) : 0 代表正，1 代表为负

* 移码 等于 补码，把符号改成相反的。

* 对于 正数 而言，码、反码、补码、移码 都一样；

* 对 负数 而言，反码除符号位外（符号位保持不变），

    * 反码：在 原码 的基础上按位取反。

    * 补码：在 反码 的基础之上，在其最低位上加 1。
    
    * 移码：先求出 补码，把符号位改成相反的

* 指数位(Exponent)：用于存储科学计数法中的指数数据，并且采用移位存储。

**阶码** 是用 移码 表示的。

这里会有一个 127 的偏移量，相当于 阶码 的最高为 阶码值 的符号位：阶码 的最高位 为 0 时，表示 阶码  负数；阶码 的最高位 为 1 时，表示 阶码  正数，
* 阶码值为 127 时相当于 0；
* 阶码值小于 127 时为 负；
* 阶码值 大于 127 时为 正。


比如阶码：1000 0001 表示 指数 为 129 - 127 = 2,表示 真值 为 2<sup>2</sup> 。而 01111110 则表示 2<sup>-1</sup>. 

为什么用**移码**表示**阶码**？

主要是**移码**便于对 阶 进行操作，从而比较两个浮点数的大小。

这里要注意的是，阶码 不能达到 11111111 的形式，即 0XFF。IEEE规定，当编译器遇到阶码为 0XFF 时，即调用溢出指令。

总之，阶码 化为整数时，范围是：[-127, 127]

float：符号位 1 bit，阶码 08 bit (固定偏移 7F)，尾数23 bit，有固定隐含位（有小数点隐含位置）

double：符号位 1 bit，阶码 11 bit (固定偏移 3FF)，尾数 52 bit，有固定隐含位（有小数点隐含位置）

long double：符号位1 bit，阶码 15 bit (固定偏移 3FFF)，尾数64 bit，固定隐含位无 

某些编译器中把 long double 作为 double 处理 

尾数部分（Mantissa）：尾数部分

其中 float 的存储方式如下图所示：

![float](./images/double_structure/float.png)

![float示例](./images/double_structure/float_示例.png)

### 精度
float 和 double 的精度是由 尾数的位数 来决定的。浮点数在内存中是按科学计数法来存储的，其整数部分始终是一个隐含着的 “1”，由于它是不变的，故不能对精度造成影响。

float：2^23 = 8388608，十进制一共七位，这意味着最多能有 7 位有效数字，但绝对能保证的为6位，也即 float 的精度为 6~7 位有效数字；

double：2^52 = 4503599627370496，十进制一共 16 位，同理，double的精度为 15~16 位。 

 
## 浮点数的值范围
最近看了 IEEE754 浮点数的表示方法。在 C 的参考书中有提到 float 类型数据的表示范围为 -3.4 * 10^38 ~ +3.4 * 10^38。究竟如何计算该范围，分析如下：

对于单精度浮点数（float）来说，有一位符号位，指数位共8位，尾数共23位。

指数能够表示的指数范围为 [-128, 127] 。

尾数为23位。当尾数全 1 时再加上小数点前面的 1，指数 取到最大正数127（8位，正数最大127，负数最小-128）,浮点数取得正数的最大值。

+1.1111111 11111111 11111111<sub>(2)</sub> * 2^127（1.后面23个1，由于尾数值的范围是 [1, 2)，其最高位总为 1，故只需存取小数部分，所以小数为是 23 位 1），约等于 2 * 2^127 = 3.4 * 10^38。

负值的最小值为即为最大正值 的相反数，即 -3.4 * 10^38


Double 的计算与此类似，double 的符号位为 63 位，指数为 第62位 ~ 第52位，共11位。表示的范围是 [-1024, 1023]。尾数为 第51位 ~ 第0为。

表示的范围为 +1.1111 11111111 11111111 11111111 11111111 11111111 11111111<sub>(2)</sub> * 2^1023  （1.后面52个1）为 1.7 * 10^308。负数亦然。
